Java8

- 함수형 인터페이스과 람다 표현식
  - 추상함수가 단 하나인 경우를 뜻함 -> @FunctionalInterface 추가하여 견고하게
  - 람다 표현식 - 인터페이스를 사용하여 함수를 간단하게 바꿔주는 것 ( 한 줄일 경우에만 오버라이딩 가능 )
    - 사실상 내부 변수가 바뀌지 않는 경우 effective final 이라고 해서 임시/로컬/람다에서 모두 사용 가능. (원래는 명시적 Final 필요)
    - 람다 클래스는 다른 두 가지와 다르게 쉐도잉이 없다. -> scope이 같기 때문에
    - 메소드 레퍼런스
      - 새로운 메소드를 만들지 않고 기존에 존재하는 것을 참조
      - 인스턴스, 생성자,스태틱 모두 가능
        - Function<String, Greeting> gre = greeting::new; // String 받아서 Greeting 생성
        - Supplier<Greeting>gre = greeting::new; //아무 변수도 안받는 생성자
        - 임의 객체에 인스턴스 메소드도 가능 ㄷㄷ Arrays.sort(names, String::compareToIgnoreCase);
  - 2장점
    - 함수를 First class object 로 사용할 수 있다. (First class 란 제한 없이 아무데서나 쓸 수 있음을 뜻함)
    - 순수 함수(Pure Function)
      - 사이드 이펙트 x (함수 밖 변경 x)
      - 상태 x (함수 밖에서 정의됨)
    - 고차 함수(High-Order Function)
      - 매개변수와 리턴값으로 함수 가능
    - 불변성
      - 입력과 출력이 일대일 대응
  - Java 가 기본으로 제공하는 함수형 인터페이스
    - java.util.function 패키지
    - 자바에서 미리 정의해둔 자주 사용하는 함수 인터페이스
    - Function<T,R>
      - T 타입을 받아서 R 타입 리턴하는 함/인
        - R apply(T t) == Function<T, R>
      - 함수 조합용 메소드 apply 로 값 전달
        - andThen
          - 계산 후 리턴값을 뒤에
        - compose
          - 안에 함수 실행 후 리턴값을 인풋으로 사용
          - a.compose(b)
            - b 계산 후 a에 넣음
    - BiFunction<T, U, R>
      - 두 개의 값 T, U 를 받아서 R 타입 리턴
        - R apply(T t, U u) == BiFunction<T, U, R>
    - Consumer<T>
      - T 타입 받기만 함  accept로 받기
        - void Accept(T t) == Consumer<T>
      - 함수 조합용 메소드
        - andTHen
    - Supplier<T>
      - T 타입의 값을 제공하는 함수 인터페이스
        - T get() == Supplier<T>
    - Predicate<T>
      - T 타입을 받아서 boolean 리턴
        - boolean test(T t) == Predicate<T>
      - 함수 조합용 메소드
      - And
      - Or
      - Negate
    - UnaryOperator<T> 
      - 입출력 모두 T
    - BinaryOperator<T>
      - 입력2개, 출력1개 모두 T
  - 인터페이스 기본 메소드와 스태틱 메소드
    - 인터페이스에 추가 기능이 필요할 경우 그냥 추가하면 싹 다 에러나니까 default 키워드를 앞에 붙여서 선언해준다. -> 하위 모든 것들이 해당 메소드를 갖게 됨 -> 무슨 값이 올지 모르니 런타임 에러가 발생할 수 있으므로 반드시 문서화 할 것. @implSpec,javadoc 사용 -> Object 에서 정의한 메소드들은 재정의 할 수 없다. + 내가 만든 interface 만 기본 메소드 제공 가능. 더이상 필수구현 안해도돼용!
    - 인터페이스에 스태틱 메소드를 제공할 수 있다.
    - 기본 메소드
      "자바8에서 추가한 기본 메소드로 인한 API 대표적인 변화
      "
      - Iterable
        - forEach()
        - spliterator()
          - spliterator.trySplit() 하면 병렬적으로 가능.
      - Collection
        - stream() / parellelStream()
        - removeIf(Predicate)
        - spliterator()
      - Comparator
        - reversed()
        - thenComparing()
        - static reverseOrder() / naturalOrder()
        - static nullsFirst() / nullsLast()
        - static comparing()
      - Stream API
        "연속된 데이터를 처리하기 위한 오퍼레이터들의 모음반으로 자르고 또 반으로 자르고 포장하고.. 흘려보내듯이
        
        "
        - 특징
          - 컬렉션 아님
          - Functional in nature = 데이터 소스 변경x
          - 스트림 처리하는 데이터는 딱 한 번 
          - 무제한일 경우 (실시간) Short Circuit 메소드를 사용해서 제한 가능
          - 중개 오퍼레이션은 Lazy 하다.
            - vs 종료(터미네이트) 오페레이션
              - 중개 : Stream 을 리턴
              - 종료 : 다른 타입 리턴
            - 중개 오퍼레이터는 종료 오퍼레이터가 실행되기 전까지는 실행되지 않는다.
        - 사용 예제
          "항상 스트림에 어떤 타입이 지나가는지 확인
          "
          - 걸러내기
            - Filter(Predicate)
            - 예) 이름이 3글자 이상인 데이터만 새로운 스트림으로
              - name.stream().filter(s->{return s.length>=3;});
          - 변경하기
            - Map(Function)
            - FlatMap(Function)
              "들어있는거 다 펴줌
              "
          - 무제한 스트림
            - Stream.iterate(seed, lambda).skip(스킵할 개수).limit(최대 개수).forEach(System.out::println);
      - Optional API
        "자바8 컨테이너 인스턴스 타입(비어있을 수 있음)
        "
        - null pointer exception 방지 가능(박스에 담아주는 것과 유사)
          - throw exception 을 하면 스택트레이스를 찍어두기 때문에 리소스가 사용되어서 비쌈.
        - return 으로만 쓰는 것이 권장됨. of 이면 null이 아님을 보장해야하고, ofNullable 이면 null pointer 일수도 있따. (물론 ifPresent() 는 있을 수 있으나 null 을 넘기는 경우 오류발생할 수 있음.)
          - 매개변수(체크할 거 늘어남), 맵의 키(키값이 null이면 안됨), 인스턴스 필드 타입(도메인 클래스 설계 문제) 쓰기 금지.
        - primitive 타입은 따로 있음 OptionalInt 등 성능에 직결.(박싱)
        - Optional 쓰면 null 을 리턴하지 말고 optional의 empty() 를 리턴하자.. null 리턴하면 optional 쓰는 의미가 없어짐.
        - 컨테이너 타입을 Optional 로 감싸지 말자. 자체적으로 빈 것을 알 수 있는 함수가 있음.
        - public Optional<type> function(){ return Optional.ofNullable(progress);}
        - Optional 값 다루기
          - get() 
            - 값 가져오기. 단 비어있는 Optional 에서 한다면 런타임오류
          - ifPresent(Consumer)
            - 만약 뭐가 있으면 가져오삼
          - orElse(T)
            - 값이 있으면 가져오고 없으면 T를 리턴해
          - orElseGet(Supplier)
            - 값이 있으면 가져오고 없는 경우에 ~해라
          - orElseThrow()
            - 값이 있으면 가져오고 없으면 에러 던지기
        - 
      - Date/Time API
        - 원래 불편했던 점
          - 이름이 모호함. 뭐가 뭔지 모르겠음ㅋㅋㅋ Timestamp
          - mutable 이라 thread safe하지 않다. SetTime이 가능 ㄷ
          - int 만 매개변수에 있기 때문에 type safety가 없음
        - 타임스탬프는 Instant 사용 기계용
        - LocalDate(날짜), LocalTime(시간), LocalDateTime(일시) 사용가능, DateTimeFormatter(일시를 특정 문열로 포맷팅) ZonedDateTime(존 설정, 뒤에 붙음, instant 랑 변환 가능)
        - immutable 이기 때문에 새로운 instant 를 반환
        - 기간 Period(인간) duration(기계)
- Concurrent 프로그래밍
  - 동시에 여러 작업을 할 수 있는 소프트웨어
    - 프로세스 vs 쓰레드
      - 프로세스는 프로그램이 실행되면 안에서 같이 실행되는 일종의 과정이라고 보면 될 듯.
      - 쓰레드는 프로세스 안에서 일을 처리하는 일꾼이라고 보면 될 듯.
    - 멀티프로세싱(ProcessBuilder)
      - Fork/Join 많이 사용함.
    - 멀티쓰레드
      - 1. 쓰레드를 상속받아서 run 메소드 구현하기
      - 2. runnable 로 사용
      - 문제점 
        - 쓰레드가 많아지면 신경쓸게 너무 많아짐. interrupt, join 등으로 관리하기 무리. -> Executor 
      - 3. Executors
        - thread를 만들고 관리하는 것을 담당.
        - Executor 있지만 아ㅏㄴ쓰고 ExecutorService 를 주로 사용
      - 지금까지는 Runnable 로 했기 때문에 return type 이 void 였다. 만약 실행 결과로 무언가 리턴받고 싶다면 다른 방식을 써야한다. 
      - 4. Callable (return 가능) == Future
        - Callable<Type> c = () ->{ ~~ return something ; } ;
        - 기존 5에서 제공하던 것은 외부에서 완료 시킬 수 없고 리턴 받은 후 쓰기가 굉장히 힘들었음.
        - implements
          - Future
          - CompletionStage
        - 비동기로 작업 실행하기
          - 리턴값이 없는 경우 : runAsync()
          - 리턴값이 있는 경우 : supplyAsync()
          - 원하는 Executor(쓰레드풀)을 이용해서 실행도 가능(ForkJoinPool.commonPool())
          - 스레드풀 없이 어떻게 견고하게 가능하냐 -> ForkJoinPool 새로 들어옴 -> deque (후입선출) 스레드가 자기 할 일을 가져와서 하는 프레임워크 -> 서브 테스크들을 쪼개서 다른 스레드로 퍼뜨려서 일하고 모아서 결과를 내보내는 프레임워크. 원하면 풀 만들어서 줘도 됨.
          - 순서 상관 o thenCompose
          - 순서 상관 x thenCombine
          - 모두 끝나게 한 후 뭔가 하고 싶다 : allOf 
            - 에러가 있었을 수도 있고, 결과값도 타입을 보장할 수 없어서 void 로 나올것.(null)
          - 추가 공부 ForkJoinPool 과 Flow API
          - ForkJoinPool(자바7)
            - 분할정복식
          - Flow API(자바9)
- Annotation 변화
  - 기초
    - 용도
      - 컴파일러 문법 에러 체크
      - IDE 빌드/배치시 코드 자동 생성 정보 제공
      - 런타임시 특정 기능 실행 정보 제공
    - 종류
      - 자바 코드에 적용되는 내장
        - @Override
          - 메서드가 오버라이드 됨
          - 상위 클래스에서 찾을 수 없으면 컴파일 에러
        - @Deprecated 
          - 해당 메서드 더 이상 사용x
          - 사용할 경우 컴파일 경고
        - @SuppressWarnings
          - 선언한 곳 컴파일 경고 무시
        - @SafeVarargs
          - 제네릭 같은 가변인자의 매개변수 사용할 때 경고 무시
        - @FunctionalInterface 
          - 함수형 인터페이스 지정
          - 메서드 x 혹은 2개 이상이면 컴파일 에러(default 제외)
      - 기타 (메타 어노테이션)
        - @Retention
          - 컴파일러가 어노테이션 다루는 방법 기술
          - 영향 미치는 시점 결정
          - RetentionPolicy.SOURCE
            - 컴파일 전까지만 유효
          - RetentionPolicy.CLASS
            - 클래스를 참조할 떄까지만 유효
          - RetentionPolicy.RUNTIME
            - 컴파일 후에도 계속 참조 가능
        - @Documented
          - 해당 어노테이션을 Javadoc에 포함
        - @Target
          - 어노테이션이 적용할 위치 선택
          - 자바8 추가된 거
            - ElementType.TYPE_PARAMETER
              - 파라미터 앞에다가 선언할 수 있게 도와줌.
            - ElementType.TYPE_USE 
              - 어디던지 선언할 수 있게 도와줌
        - @Inherited
          - 어노테이션의 상속 가능
        - @Repeatable
          - 연속적으로 같은 어노테이션 선언가능
      - 커스텀 어노테이션
        - 1.정의, 2. 적용, 3.어노테이션 이용 코드 수행
          - value(), number() 등이 어노테이션 호출할 때 준 인자랑 통하게 되고 없을 경우 default 사용
            "String value() default "-";"
        - @Retention(RetentionPolicy.RUNTIME) public @interface Count100 
        - 런타임 중에 유효한 어노테이션을 만들거고, 어노테이션은 @interface + 이름 으로 정의
        - Method m = object.getClass().getDeclaredMethod("어노테이션붙인함수이름");
        - if (m.isAnnotationPresent(어노테이션명.class)) { do something};
      - 중요
        - @Retention 해당 어노테이션을 언제까지 유지할 것인가? 소스 클래스 런타임
        - @Inherit 해당 어노테이션을 하위 클래스까지 전달할 것인가?
        - @Target 어디에 사용할 수 있는가?
  - 1. 타입 선언부도 사용할 수 있게 됨
  - 2. 중복해서 사용할 수 있게 됨.
- 배열 Parallel 정렬
  - 효율 바뀜 x 쓰레드를 분산해서 쓰기 때문에 조금 더 빠를 순 있다.
  - Arrays.parallelSort(something);
- Metaspace
  - JVM 메모리 영역 중 PermGen 이 사라지고 Metaspace 영역이 생김
  - Garbage Collection . Heap에  Young Generation Old Generation (Java8 부터 perm영역 제거)
    - Garbage Collection
      - Garbage 란 유효하지 않은 메모리를 뜻함
      - C/C++ 의 free() 혹은 delete 의 역할을 주기적으로 검사하여 메모리 청소 해주는 녀석
        - System.gc() 를 이용해 직접 호출할 수 있지만 성능에 큰 영향을 미친다고 한다...
      - 전제
        - 1. 대부분의 객체는 금방 접근 불가능한 상태가 된다.(Unreachble)
        - 2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.
      - Young Generation
        - 새롭게 생성된 객체가 할당됨
        - Unreachable이 되면 사라짐
        - Minor GC
        - 구조
          - Eden 1영역 
            - 새로 생성된 객체가 할당되는 영역
            - Eden 이 꽉 차면 Minor GC 발생 -> 사용x 해제, 사용 중이면 Survivor 영역1로 이동
            - Survivor 영역1이 가득 차면 Survivor 영역2로 이동시켜 주고 영역2를 사용한다. (둘 중 하나는 무조건 빔)
            - 반복해서 살아남은 객체들을 Old Gen 으로 Promotion
            - HotSpot JVM 
              -  bump the pointer (Eden 영역 마지막으로 할당된 객체 주소 캐싱하고 다음 주소 사용) 
              - TLABs(Thread-Local Allocation Buffers) 멀티쓰레드에서 락 걸어 동기화하는 것을 피하기 위해 각 쓰레드마다 Eden 영역에 객체를 할당하기 위한 주소를 부여해서 동기화 작업 없이 할당.
          - Survivor 두 영역
            - 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
      - Old Generation
        - Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
        - 복사되는 과정에서 대부분 Young 영역보다 크게 할당되며, 큰만큼 가비지는 적게 발생
        - Major GC or Full GC
          - 객체들이 계속 Promotion 되어 Old 영역 메모리가 부족해지면 발생.
          - Minor GC 보다 훨 크고 복잡해서 10배 이상 걸림
        - Old 영역의 객체가 Young 영역 객체를 참조하는 경우 512B 의 Card Table 에 기록하고, Young 영역 GC 할 때 Card Table 만 조회하여 식별 (일반적으로 Young Table 영역 객체를 식별하는게 비효율적이라서)
      - 작동방식
        - 1. Stop The World
          - JVM 상의 모든 thread를 GC thread 제외하고 멈춤
        - 2. Mark and Sweep
          - Mark : 사용되는 메모리와 아닌 메모리 식별
          - Sweep : 사용하지 않는 메모리 해제
        - 
  - Perm Generation
    - 클래스 메타 데이터를 담는 곳. (그렇게 크진 않음)
      - [Eden] [Old, Old] [PermGen] 
      - Heap영역에 속함
      - XX:PermSize=N (초기사이즈)
      - XX:MaxPermSize =N (최대사이즈)
      - 기본값으로 제한된 크기
    - 만약 클래스가 너무 많이 생성되거나 하면 permGen GC 하지만 그래도 넘치면 error 
      "굉장해 엄청나!
      "
  - Metaspace
    - 클래스 메타데이터를 PermGen 대신 담음
    - 총 유용가능메모리 = [Eden] [Old Old] [Metaspace](NativeMemory)
    - 크기제한 x (필요한 만큼 늘어남)
      - OS에 있는 메모리 다 찰 때까지 늘어남 ㄷ -> 서버 대폭발 -> 최대 사이즈 설정
        - MetaspaceSize = N (초기사이즈
        - MaxMetaspaceSize =N(최대사이즈)
    - java8부터 permGen 관련 java옵션 무시
- 바이트코드 조작 툴 활용
  - javac 컴파일 시 바이트코드로 파일이 변환되며, 그것을 해석하여 프로그램이 실행된다.
  - 자바파일이 언제 어디서 실행되는지 디버그 할 수 있음..! -> 코드 커버리지 Jacoco
  - 코드 커버리지
    - 테스트 케이스가 얼마나 충족되었는지를 나타내는 지표
      - 올바른 케이스와 올바르지 않은 케이스를 넣어서 테스트.
      - 분기는 노란색 지나간 곳은 초록색 안지나간 곳은 빨간색
      - 통과 퍼센티지 설정하여 신뢰도 업 가능
    - 코드에서 버그를 찾거나 코드 복잡도 계산 가능.
  - 클래스 파일 생성/조작
    - 원래 소스코드 대신 사용할 프록시를 만든다던가 특정 API 호출 접근 제한, 스칼라 같은 언어의 컴파일러 바이트 코드 생성하여 JVM 에서 돌아갈 수 있도록 활용.
    - 소스 코드 건드리지 않고 코드 변경이 필요한 경우
      - 프로파일러 - 메모리/스레드 개수.. 등등 성능 분석 툴 
      - 최적화
      - 로깅
      - ..
    - javaagent
      - Instrumentation을 사용한다.
      - 클래스로더가 클래스를 읽어올 때 javaagent를 거쳐서 변경된 바이트코드를 읽어들여 사용한다.
      - premain
        - public static void premain(String agentArgs, Instrumentation inst) 정의 필요 => 클래스를 바꾸는 등의 기능을 위해서 pom.xml(Maven 특징)과 premain 내 정의가 필요하다.
        - 시작시 클래스에 붙이는 방식
        - bytebuddy API 사용
          - class 파일에다가 직접 바이트코드 삽입하여 저장..!
          - pom.xml 의 dependencies 수정 필요
      - agentmain
        - 런타임 중에 동적으로 붙이는 방식 
  - 스프링이 컴포넌트 스캔을 하는 방법(asm)
    - 컴포넌트 스캔으로 빈으로 등록할 후보 클래스 정보를 찾는데 사용 (annotation)
    - ASM, Javassist, ByteBuddy, CGlib 참고
  - 리플렉션 API
    - 의의  : 런타임 중 리플렉션 API를 통해 annotation을 활용할 수 있게 해준다.
    - 주의
      - 지나친 사용은 성능 이슈를 야기할 수 있으니 반드시 필요한 경우에만 사용
      - 런타임 시에만 발생하는 문제를 만들 수 있다.
      - 접근 지시자를 무시할 수 있다.
    - 스프링
      - 의존성 주입할 때 사용
      - MVC 뷰에서 넘어온 데이터를 객체에 바인딩 할 때 사용
    - 클래스 정보 조회
      - Arrays.stream(certainClass.getDeclaredFields()); methods 다 가능 , forEach(System.out::rintln); 
      - Arrays.stream(f.getAnnotations()).forEach(a -> { if (a instanceof MyAnnotation){ MyAnnotation myAnnotation = (MyAnnotation) a; System.out.println(myAnnotation.value()); System.out.println(myAnnotation.number());}});});
      - 만약 fields 를 가져오고 싶다면 객체를 생성한 후 o.accesible 해주면 전부 접근권한이 생긴다.
      - getAnnotations() 
        - 상속받은(@Inherit ) 애노테이션까지 조회 가능
      - getDeclaredAnnotations()
        - 자기 자신에만 붙어있는 애노테이션 조회
    - 커스텀 annotation
      - @interface MyAnnotation 으로 선언. 
      - String value() default "asdf";
      - int number() default 199;
    - 클래스 정보 수정 또는 실행
      - 직접 접근할 수 없는 경우 package 를 통해 접근
      - 직접 접근하여 수정할  수 없는 경우 혹은 static 변수도 변경이 가능하다. o.setAccible(true);
      - 객체 하나와 클래스 레퍼런스만 이용해서 사용 가능.
    - 나만의 DI 프레임워크 만들기
      - ?
    - 다이나믹 프록시
      - 프록시 패턴
        - 프록시와 리얼 서브젝트가 공유하는 인터페이스 서브젝트가 있다.
        - 클라이언트는 사실상 프록시를 사용함
        - 클라이언트 -> 프록시 -> 리얼 서브젝트 (대리인 혹은 비서) SRP software참고
        - 리얼 서브젝트에는 자신이 해야 할 일만 하면서 프록시를 사용하여 부가적인 기능(접근 제한, 로깅, 트랜잭션..) 제공할 때 패턴 사용.
      - 런타임에 특정 인터페이스들을 구현하는 클래스 또는 인스턴스를 만드는 기술 -> 일반적인 프록시의 경우 모든 추상 메소드를 구현해야 하기 때문에 하나만 수정하기 힘들다. 고로 invoke() method 를 통해 하나만 구현하고 나머지는 자동 구현을 사용함으로써 이 문제를 해결한다.
      - 사용처
        - 스프링 데이터 JPA
        - 스프링 AOP
        - Mockito
        - 하이버네이트 lazy initialization
- 테스트 코드
  - 방법
    - @Test annotation 사용하여 테스트 수행하는 메소드 표시
    - asswertJ 테스트 검증 라이브러리 사용
    - JUnit5 자바 단위 테스팅 프레임워크
    - @DisplayName("") 을 사용하여 읽기 좋은 이름 부여 가능
  - 패턴
    - given(준비)
      - 데이터가 준비 되었다.
      - 데이터 불러오기, 객체 생성
    - when(실행)
      - 함수를 실행한다.
      - 검증할 함수 실행
    - then(검증)
      - 특정 결과가 나와야한다.
      - assertThat( something.isEqualTo()); or stream사용하여 true/false 확인
- 애노테이션 프로세서
  - 롬복 ProjectLombok 은 어떻게 동작할까?
    - 컴파일시에 소스코드의 AST(abstract syntax tree)를 조작한다.
    - Intellij 의 경우 plugin 다운, annotation processor 활성화시켜줘야함.
    - Getter Setter EqualsAndHashCode 를 직접 구현하지 않아도 어노테이션으로만 구현할 수 있다. @Getter @Setter @EqualsAndHashCode
    - 논란
      - 공개된 API가 아닌 컴파일러 내부 클래스를 사용하여 기존 소스 코드를 조작한다.(해킹?)
      - 이클립스의 경우 java agent 를 사용하여 컴파일러 클래스까지 조작하여 사용한다. -> 비공개API이다보니 버전 호환성 문제가 생길 수 있음
      - 편리함 때문에 사용하고 대체제가 거의 전무하다. (AutoValue , Immutables)
